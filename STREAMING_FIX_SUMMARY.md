# AI Streaming Real-Time Updates Fix

## Problem Summary

The Brain pages were not displaying AI message streams in real-time. Tokens were being generated by the AI backend, but the React components weren't updating as tokens arrived.

## Root Causes Identified

### 0. **CRITICAL: Race Condition in Event Handler** (Newly Identified)
**Location:** `/src/renderer/src/hooks/useAI.ts`

**Issue:** Events arriving before the runId was set, causing all early tokens to be silently ignored.

```tsx
// BEFORE (buggy)
if (event.type === 'token' && currentRunIdRef.current) {
  const data = event.data as { runId: string; token: string }
  if (data.runId === currentRunIdRef.current) {
    // Process token
  }
}
```

**The race condition:**
1. User submits prompt → `window.ai.inference()` called (async)
2. Main process immediately starts generating tokens
3. Token events arrive at renderer via IPC `pipeline:event`
4. Event handler checks `if (event.type === 'token' && currentRunIdRef.current)`
5. **BUG:** `currentRunIdRef.current` is still `null` (promise hasn't resolved yet)
6. **RESULT:** Early tokens silently ignored!

**Fixed with defensive handling:**
```tsx
// AFTER (fixed)
if (event.type === 'token') {
  const data = event.data as { runId: string; token: string }

  // CRITICAL FIX: Set runId from first token if not set yet
  if (!currentRunIdRef.current) {
    console.warn('[useAI] Token arrived before runId was set. Setting it now:', data.runId)
    currentRunIdRef.current = data.runId
    accumulatedContentRef.current = ''
    assistantMessageIdRef.current = null
  }

  if (data.runId === currentRunIdRef.current) {
    // Process token
  }
}
```

**Additional improvements:**
- Added comprehensive event logging with bracketed output
- Added warnings for mismatched runIds
- Added event-specific logging for done/error events

### 1. **Component Displayed Stale Message Content** (Critical)
**Location:** `/src/renderer/src/components/brain/BrainSimpleLayout.tsx`

**Issue:** The component had access to `latestResponse` from the useAI hook, which updates in real-time during streaming. However, it was displaying `latestAssistantMessage.content` from the messages array instead.

```tsx
// BEFORE (incorrect)
const latestAssistantMessage = messages
  .filter(m => m.role === 'assistant')
  .slice(-1)[0]

// Display stale content
{latestAssistantMessage.content}
```

**Why this failed:**
- `latestResponse` updates on every token via `setLatestResponse()` (line 98 in useAI.ts)
- The messages array only updated when `setMessages()` was called (on every token)
- Displaying the message content meant React was re-rendering but showing the same stale reference

### 2. **Wrong useEffect Dependencies for Auto-Scroll**
**Location:** `/src/renderer/src/components/brain/BrainSimpleLayout.tsx`

```tsx
// BEFORE (incorrect)
useEffect(() => {
  if (contentRef.current && isStreaming) {
    contentRef.current.scrollTop = contentRef.current.scrollHeight
  }
}, [messages, isStreaming])  // ❌ Depended on messages array
```

**Why this failed:**
- During streaming, `latestResponse` was updating, not the messages array reference
- The effect would only fire when the entire messages array changed
- Auto-scroll wouldn't trigger on each token

### 3. **Inefficient State Updates on Every Token**
**Location:** `/src/renderer/src/hooks/useAI.ts`

**Issue:** The hook was updating the messages array on EVERY token, creating unnecessary re-renders and state mutations.

```tsx
// BEFORE (inefficient)
setMessages(prev => {
  const assistantMsgId = assistantMessageIdRef.current
  if (!assistantMsgId) {
    // Create new message
  }
  // Update existing message on EVERY token
  return prev.map(msg =>
    msg.id === assistantMsgId
      ? { ...msg, content: accumulatedContentRef.current }
      : msg
  )
})
```

**Performance impact:**
- Creating new arrays on every token
- Unnecessary map operations
- React re-rendering entire message list on each token

## Solutions Implemented

### 1. **Display Streaming Content Correctly**

Added logic to show `latestResponse` during streaming and fallback to completed message content:

```tsx
// AFTER (correct)
const displayContent = isStreaming
  ? latestResponse
  : (latestAssistantMessage?.content || '')

// In JSX
{displayContent}
```

**Benefits:**
- Real-time updates as `latestResponse` changes
- Smooth transition to completed message after streaming
- Single source of truth for displayed content

### 2. **Fixed useEffect Dependencies**

```tsx
// AFTER (correct)
useEffect(() => {
  if (contentRef.current && isStreaming) {
    contentRef.current.scrollTop = contentRef.current.scrollHeight
  }
}, [latestResponse, isStreaming])  // ✅ Depends on latestResponse
```

**Benefits:**
- Effect fires on every token arrival
- Smooth auto-scrolling during streaming
- Correct dependency tracking

### 3. **Optimized State Updates in useAI Hook**

**Changed strategy:**
- Create assistant message placeholder ONCE on first token
- Update ONLY `latestResponse` during streaming
- Update messages array ONCE when streaming completes

```tsx
// AFTER (optimized)
if (isFirstToken) {
  setIsStreaming(true)
  onStreamStart?.()

  // Create placeholder once
  const newId = `msg-${Date.now()}`
  assistantMessageIdRef.current = newId

  setMessages(prev => [
    ...prev,
    {
      id: newId,
      role: 'assistant',
      content: '',
      timestamp: Date.now()
    }
  ])
}

// Only update latestResponse during streaming
setLatestResponse(accumulatedContentRef.current)
```

**When streaming completes:**
```tsx
// Update final content once
if (assistantMsgId) {
  setMessages(prev =>
    prev.map(msg =>
      msg.id === assistantMsgId
        ? { ...msg, content: finalResponse }
        : msg
    )
  )
}
```

**Performance benefits:**
- Messages array updated 2x total (create placeholder + final update)
- Previously: N updates for N tokens
- Significant reduction in React re-renders
- Reduced memory allocations

## React Best Practices Applied

### 1. **Optimized State Updates**
- Minimize state updates during high-frequency operations (streaming)
- Use refs for accumulation (`accumulatedContentRef`)
- Update state only when UI needs to reflect changes

### 2. **Correct useEffect Dependencies**
- Dependencies match actual values used in the effect
- Prevents stale closures
- Ensures effects fire at the right time

### 3. **Single Source of Truth**
- `latestResponse` for streaming content
- `messages[].content` for completed messages
- Component logic determines which to display

### 4. **Memory Efficiency**
- Reduced array allocations during streaming
- Fewer object spreads
- Less garbage collection pressure

## Files Modified

1. **`/src/renderer/src/components/brain/BrainSimpleLayout.tsx`**
   - Added `displayContent` logic (line 75)
   - Updated JSX to use `displayContent` (line 103)
   - Fixed useEffect dependencies (line 48)

2. **`/src/renderer/src/hooks/useAI.ts`**
   - Optimized token event handler (lines 86-108)
   - Moved message creation to first token only
   - Added final content update on stream completion (lines 140-147)

## Testing Checklist

- [ ] Verify tokens appear in real-time during streaming
- [ ] Confirm auto-scroll works smoothly during streaming
- [ ] Check that completed messages persist correctly
- [ ] Test multiple consecutive queries
- [ ] Verify error handling during streaming
- [ ] Test cancel functionality during streaming
- [ ] Check memory usage with DevTools profiler
- [ ] Verify no console errors during streaming

## Performance Metrics

**Before:**
- State updates per 1000 tokens: ~1000 (messages array) + 1000 (latestResponse) = 2000
- Array allocations: ~1000
- Re-renders: High frequency

**After:**
- State updates per 1000 tokens: 2 (messages array) + 1000 (latestResponse) = 1002
- Array allocations: 2
- Re-renders: Only when latestResponse changes (expected)

**Improvement:** ~50% reduction in state updates, ~99.8% reduction in array allocations

## Additional Notes

- The `React.memo` wrapper on `BrainSimpleLayout` may prevent re-renders if props don't change. This is generally fine, but if issues arise, consider removing it or providing a custom comparison function.
- The component could be further optimized by using `useMemo` for the `displayContent` calculation, though the current implementation is already efficient.
- Consider adding `React.useTransition` for smoother updates if streaming feels janky on slower devices.

## Related React Concepts

1. **Stale Closures:** Event handlers capturing old state values
2. **useEffect Dependencies:** React's dependency array for effect re-runs
3. **State Update Batching:** React batches updates for performance
4. **Reference Equality:** React compares references for re-render decisions
5. **Performance Optimization:** Minimizing unnecessary renders and state updates
